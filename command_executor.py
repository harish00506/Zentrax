"""
Windows Command Executor
Executes structured JSON commands generated by the WindowsCommandGenerator.
"""

import os
import subprocess
import shutil
import json
import ctypes
from typing import Dict, Any, Optional, Tuple
from datetime import datetime

# Try to import pyautogui for keyboard/mouse actions
try:
    import pyautogui
    PYAUTOGUI_AVAILABLE = True
except ImportError:
    PYAUTOGUI_AVAILABLE = False
    print("‚ö†Ô∏è  pyautogui not available. Some features will be limited.")

# Try to import win32gui for window management
try:
    import win32gui
    import win32con
    WIN32_AVAILABLE = True
except ImportError:
    WIN32_AVAILABLE = False


class CommandExecutor:
    """
    Executes structured Windows commands.
    """
    
    def __init__(self):
        self.username = os.environ.get("USERNAME", "User")
        self.user_home = os.path.expanduser("~")
        
        # Common application paths
        self.app_paths = {
            "chrome.exe": [
                r"C:\Program Files\Google\Chrome\Application\chrome.exe",
                r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
                os.path.join(self.user_home, r"AppData\Local\Google\Chrome\Application\chrome.exe"),
            ],
            "firefox.exe": [
                r"C:\Program Files\Mozilla Firefox\firefox.exe",
                r"C:\Program Files (x86)\Mozilla Firefox\firefox.exe",
            ],
            "code.exe": [
                os.path.join(self.user_home, r"AppData\Local\Programs\Microsoft VS Code\Code.exe"),
                r"C:\Program Files\Microsoft VS Code\Code.exe",
            ],
            "msedge.exe": [
                r"C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe",
                r"C:\Program Files\Microsoft\Edge\Application\msedge.exe",
            ],
        }
        
        # System apps that can be run directly
        self.system_apps = {
            "notepad.exe": "notepad",
            "calc.exe": "calc",
            "explorer.exe": "explorer",
            "cmd.exe": "cmd",
            "powershell.exe": "powershell",
            "taskmgr.exe": "taskmgr",
            "control.exe": "control",
            "mspaint.exe": "mspaint",
            "wordpad.exe": "wordpad",
            "regedit.exe": "regedit",
            "mstsc.exe": "mstsc",  # Remote Desktop
            "snippingtool.exe": "snippingtool",
            "charmap.exe": "charmap",
            "magnify.exe": "magnify",
            "osk.exe": "osk",  # On-screen keyboard
        }
        
    def execute(self, command: Dict[str, Any]) -> Tuple[bool, str]:
        """
        Execute a structured command.
        
        Args:
            command: The command dict with action, target, path, extra
            
        Returns:
            Tuple of (success: bool, message: str)
        """
        if not command or "action" not in command:
            return False, "Invalid command: missing 'action' field"
        
        action = command.get("action", "").lower()
        
        # Map actions to handler methods
        handlers = {
            "open_app": self._open_app,
            "open_file": self._open_file,
            "open_folder": self._open_folder,
            "search": self._search,
            "search_and_open": self._search_and_open,
            "create_file": self._create_file,
            "create_and_open_file": self._create_and_open_file,
            "create_folder": self._create_folder,
            "delete": self._delete,
            "move": self._move,
            "rename": self._rename,
            "copy": self._copy,
            "maximize_window": self._maximize_window,
            "minimize_window": self._minimize_window,
            "close_window": self._close_window,
            "switch_window": self._switch_window,
            "run_command": self._run_command,
            "open_control_panel": self._open_control_panel,
            "open_settings": self._open_settings,
            "task_manager": self._task_manager,
            "keyboard_action": self._keyboard_action,
            "mouse_action": self._mouse_action,
            "volume_up": self._volume_up,
            "volume_down": self._volume_down,
            "mute": self._mute,
            "screenshot": self._screenshot,
            "lock_screen": self._lock_screen,
            "shutdown": self._shutdown,
            "restart": self._restart,
            "sleep": self._sleep,
            "system_info": self._system_info,
            "web_search": self._web_search,
            # Advanced FRIDAY controls
            "brightness_up": self._brightness_up,
            "brightness_down": self._brightness_down,
            "set_brightness": self._set_brightness,
            "wifi_toggle": self._wifi_toggle,
            "bluetooth_toggle": self._bluetooth_toggle,
            "kill_process": self._kill_process,
            "list_processes": self._list_processes,
            "media_play_pause": self._media_play_pause,
            "media_next": self._media_next,
            "media_previous": self._media_previous,
            "media_stop": self._media_stop,
            "open_url": self._open_url,
            "new_tab": self._new_tab,
            "close_tab": self._close_tab,
            "refresh_page": self._refresh_page,
            "empty_recycle_bin": self._empty_recycle_bin,
            "show_desktop": self._show_desktop,
            "open_emoji_picker": self._open_emoji_picker,
            "open_clipboard_history": self._open_clipboard_history,
            "night_light_toggle": self._night_light_toggle,
            "airplane_mode_toggle": self._airplane_mode_toggle,
            "type_text": self._type_text,
            "voice_typing": self._voice_typing,
            "scroll": self._scroll,
            "click": self._click,
        }
        
        handler = handlers.get(action)
        if not handler:
            return False, f"Unknown action: {action}"
        
        try:
            return handler(command)
        except Exception as e:
            return False, f"Error executing {action}: {str(e)}"
    
    def _find_app_path(self, app_name: str) -> Optional[str]:
        """Find the full path to an application."""
        app_name_lower = app_name.lower()
        
        # Check if it's a system app
        if app_name_lower in self.system_apps:
            return self.system_apps[app_name_lower]
        
        # Check known paths
        if app_name_lower in self.app_paths:
            for path in self.app_paths[app_name_lower]:
                if os.path.exists(path):
                    return path
        
        # Try to find in PATH
        result = shutil.which(app_name)
        if result:
            return result
        
        # Try common install locations
        program_files = [
            os.environ.get("ProgramFiles", r"C:\Program Files"),
            os.environ.get("ProgramFiles(x86)", r"C:\Program Files (x86)"),
            os.path.join(self.user_home, "AppData", "Local"),
            os.path.join(self.user_home, "AppData", "Local", "Programs"),
        ]
        
        for pf in program_files:
            for root, dirs, files in os.walk(pf):
                if app_name_lower in [f.lower() for f in files]:
                    return os.path.join(root, app_name)
                # Limit depth to avoid long searches
                if root.count(os.sep) - pf.count(os.sep) > 3:
                    break
        
        return None
    
    def _open_app(self, cmd: Dict) -> Tuple[bool, str]:
        """Open an application."""
        target = cmd.get("target", "")
        
        if not target:
            return False, "No application specified"
        
        # Handle special cases
        if target.lower() in ["ms-settings:", "settings"]:
            os.startfile("ms-settings:")
            return True, "Opened Windows Settings"
        
        # Find app path
        app_path = self._find_app_path(target)
        
        if app_path:
            subprocess.Popen([app_path], shell=True)
            return True, f"Opened {target}"
        else:
            # Try running directly (might work for some apps)
            try:
                os.startfile(target)
                return True, f"Opened {target}"
            except Exception:
                return False, f"Could not find application: {target}"
    
    def _open_file(self, cmd: Dict) -> Tuple[bool, str]:
        """Open a file with its default application."""
        path = cmd.get("path", "")
        
        if not path:
            return False, "No file path specified"
        
        # Normalize path
        path = os.path.normpath(path)
        
        if not os.path.exists(path):
            return False, f"File not found: {path}"
        
        os.startfile(path)
        return True, f"Opened {path}"
    
    def _open_folder(self, cmd: Dict) -> Tuple[bool, str]:
        """Open a folder in Explorer."""
        path = cmd.get("path", "")
        
        if not path:
            path = self.user_home
        
        path = os.path.normpath(path)
        
        if not os.path.exists(path):
            return False, f"Folder not found: {path}"
        
        subprocess.Popen(["explorer", path])
        return True, f"Opened folder: {path}"
    
    def _search(self, cmd: Dict) -> Tuple[bool, str]:
        """Search for files."""
        target = cmd.get("target", "*")
        path = cmd.get("path", self.user_home)
        
        # Open Explorer with search query
        search_cmd = f'explorer "search-ms:query={target}&crumb=location:{path}"'
        subprocess.Popen(search_cmd, shell=True)
        return True, f"Searching for '{target}' in {path}"
    
    def _search_and_open(self, cmd: Dict) -> Tuple[bool, str]:
        """Search for files and open the first match."""
        import glob
        target = cmd.get("target", "*")
        path = cmd.get("path", self.user_home)
        
        # Search for files
        search_pattern = os.path.join(path, "**", target)
        try:
            matches = list(glob.glob(search_pattern, recursive=True))[:10]  # Limit to 10
            
            if matches:
                # Open the first match
                first_match = matches[0]
                os.startfile(first_match)
                
                if len(matches) > 1:
                    return True, f"Opened: {first_match} (found {len(matches)} matches)"
                return True, f"Opened: {first_match}"
            else:
                # Fallback to Explorer search
                search_cmd = f'explorer "search-ms:query={target}&crumb=location:{path}"'
                subprocess.Popen(search_cmd, shell=True)
                return True, f"No files found locally, opened search for '{target}'"
        except Exception as e:
            return False, f"Search failed: {e}"
    
    def _create_file(self, cmd: Dict) -> Tuple[bool, str]:
        """Create a new file."""
        path = cmd.get("path", "")
        extra = cmd.get("extra", {})
        content = extra.get("content", "") if isinstance(extra, dict) else ""
        
        if not path:
            return False, "No file path specified"
        
        path = os.path.normpath(path)
        
        # Create parent directory if needed
        parent_dir = os.path.dirname(path)
        if parent_dir and not os.path.exists(parent_dir):
            os.makedirs(parent_dir)
        
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)
        
        return True, f"Created file: {path}"
    
    def _create_and_open_file(self, cmd: Dict) -> Tuple[bool, str]:
        """Create a new file and open it with an application."""
        path = cmd.get("path", "")
        extra = cmd.get("extra", {})
        app = extra.get("app", "notepad.exe") if isinstance(extra, dict) else "notepad.exe"
        
        if not path:
            return False, "No file path specified"
        
        path = os.path.normpath(path)
        
        # Create parent directory if needed
        parent_dir = os.path.dirname(path)
        if parent_dir and not os.path.exists(parent_dir):
            os.makedirs(parent_dir)
        
        # Create empty file if it doesn't exist
        if not os.path.exists(path):
            with open(path, "w", encoding="utf-8") as f:
                f.write("")
        
        # Open with specified app or default
        try:
            if app == "notepad.exe" or app == "notepad":
                subprocess.Popen(["notepad", path])
            else:
                os.startfile(path)
            return True, f"Created and opened: {path}"
        except Exception as e:
            return False, f"File created but failed to open: {e}"
    
    def _create_folder(self, cmd: Dict) -> Tuple[bool, str]:
        """Create a new folder."""
        path = cmd.get("path", "")
        
        if not path:
            return False, "No folder path specified"
        
        path = os.path.normpath(path)
        
        if os.path.exists(path):
            return False, f"Folder already exists: {path}"
        
        os.makedirs(path)
        return True, f"Created folder: {path}"
    
    def _delete(self, cmd: Dict) -> Tuple[bool, str]:
        """Delete a file or folder."""
        path = cmd.get("path", "")
        
        if not path:
            return False, "No path specified"
        
        path = os.path.normpath(path)
        
        if not os.path.exists(path):
            return False, f"Path not found: {path}"
        
        if os.path.isfile(path):
            os.remove(path)
            return True, f"Deleted file: {path}"
        else:
            shutil.rmtree(path)
            return True, f"Deleted folder: {path}"
    
    def _move(self, cmd: Dict) -> Tuple[bool, str]:
        """Move a file or folder."""
        path = cmd.get("path", "")
        extra = cmd.get("extra", {})
        destination = extra.get("destination", "") if isinstance(extra, dict) else ""
        
        if not path or not destination:
            return False, "Source path and destination required"
        
        path = os.path.normpath(path)
        destination = os.path.normpath(destination)
        
        if not os.path.exists(path):
            return False, f"Source not found: {path}"
        
        shutil.move(path, destination)
        return True, f"Moved {path} to {destination}"
    
    def _rename(self, cmd: Dict) -> Tuple[bool, str]:
        """Rename a file or folder."""
        path = cmd.get("path", "")
        extra = cmd.get("extra", {})
        new_name = extra.get("new_name", "") if isinstance(extra, dict) else ""
        
        if not path or not new_name:
            return False, "Path and new name required"
        
        path = os.path.normpath(path)
        
        if not os.path.exists(path):
            return False, f"Path not found: {path}"
        
        parent_dir = os.path.dirname(path)
        new_path = os.path.join(parent_dir, new_name)
        
        os.rename(path, new_path)
        return True, f"Renamed to {new_name}"
    
    def _copy(self, cmd: Dict) -> Tuple[bool, str]:
        """Copy a file or folder."""
        path = cmd.get("path", "")
        extra = cmd.get("extra", {})
        destination = extra.get("destination", "") if isinstance(extra, dict) else ""
        
        if not path or not destination:
            return False, "Source path and destination required"
        
        path = os.path.normpath(path)
        destination = os.path.normpath(destination)
        
        if not os.path.exists(path):
            return False, f"Source not found: {path}"
        
        if os.path.isfile(path):
            shutil.copy2(path, destination)
        else:
            shutil.copytree(path, destination)
        
        return True, f"Copied {path} to {destination}"
    
    def _maximize_window(self, cmd: Dict) -> Tuple[bool, str]:
        """Maximize a window."""
        target = cmd.get("target", "current")
        
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey("win", "up")
            return True, "Maximized window"
        
        return False, "pyautogui not available for window control"
    
    def _minimize_window(self, cmd: Dict) -> Tuple[bool, str]:
        """Minimize a window."""
        target = cmd.get("target", "current")
        
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey("win", "down")
            return True, "Minimized window"
        
        return False, "pyautogui not available for window control"
    
    def _close_window(self, cmd: Dict) -> Tuple[bool, str]:
        """Close a window."""
        target = cmd.get("target", "current")
        
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey("alt", "F4")
            return True, "Closed window"
        
        return False, "pyautogui not available for window control"
    
    def _switch_window(self, cmd: Dict) -> Tuple[bool, str]:
        """Switch to another window."""
        target = cmd.get("target", "")
        
        if PYAUTOGUI_AVAILABLE:
            if not target or target == "next":
                pyautogui.hotkey("alt", "tab")
                return True, "Switched to next window"
            else:
                # Try to find and focus the window
                pyautogui.hotkey("win", "tab")
                return True, f"Opened task view to find {target}"
        
        return False, "pyautogui not available for window control"
    
    def _run_command(self, cmd: Dict) -> Tuple[bool, str]:
        """Run a shell command."""
        extra = cmd.get("extra", {})
        command = extra.get("command", "") if isinstance(extra, dict) else ""
        
        if not command:
            return False, "No command specified"
        
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        
        if result.returncode == 0:
            return True, f"Command executed: {command}"
        else:
            return False, f"Command failed: {result.stderr}"
    
    def _open_control_panel(self, cmd: Dict) -> Tuple[bool, str]:
        """Open Control Panel."""
        target = cmd.get("target", "main")
        
        if target == "main" or not target:
            subprocess.Popen(["control"])
        else:
            # Try to open specific control panel applet
            subprocess.Popen(["control", target])
        
        return True, "Opened Control Panel"
    
    def _open_settings(self, cmd: Dict) -> Tuple[bool, str]:
        """Open Windows Settings."""
        target = cmd.get("target", "main")
        
        settings_map = {
            "main": "ms-settings:",
            "display": "ms-settings:display",
            "sound": "ms-settings:sound",
            "wifi": "ms-settings:network-wifi",
            "bluetooth": "ms-settings:bluetooth",
            "apps": "ms-settings:appsfeatures",
            "privacy": "ms-settings:privacy",
            "update": "ms-settings:windowsupdate",
            "personalization": "ms-settings:personalization",
            "accounts": "ms-settings:yourinfo",
        }
        
        uri = settings_map.get(target.lower(), f"ms-settings:{target}")
        os.startfile(uri)
        
        return True, f"Opened Settings: {target}"
    
    def _task_manager(self, cmd: Dict) -> Tuple[bool, str]:
        """Open Task Manager."""
        subprocess.Popen(["taskmgr"])
        return True, "Opened Task Manager"
    
    def _keyboard_action(self, cmd: Dict) -> Tuple[bool, str]:
        """Perform keyboard actions."""
        extra = cmd.get("extra", {})
        keys = extra.get("keys", []) if isinstance(extra, dict) else []
        
        if not keys:
            return False, "No keys specified"
        
        if not PYAUTOGUI_AVAILABLE:
            return False, "pyautogui not available for keyboard control"
        
        pyautogui.hotkey(*keys)
        return True, f"Pressed: {' + '.join(keys)}"
    
    def _mouse_action(self, cmd: Dict) -> Tuple[bool, str]:
        """Perform mouse actions."""
        extra = cmd.get("extra", {})
        
        if not isinstance(extra, dict):
            return False, "Invalid mouse action parameters"
        
        action = extra.get("action", "click")
        x = extra.get("x")
        y = extra.get("y")
        
        if not PYAUTOGUI_AVAILABLE:
            return False, "pyautogui not available for mouse control"
        
        if x is not None and y is not None:
            pyautogui.moveTo(x, y)
        
        if action == "click":
            pyautogui.click()
        elif action == "double_click":
            pyautogui.doubleClick()
        elif action == "right_click":
            pyautogui.rightClick()
        
        return True, f"Mouse {action} performed"
    
    def _volume_up(self, cmd: Dict) -> Tuple[bool, str]:
        """Increase volume."""
        extra = cmd.get("extra", {})
        amount = extra.get("amount", 10) if isinstance(extra, dict) else 10
        
        if PYAUTOGUI_AVAILABLE:
            # Press volume up key multiple times
            presses = max(1, amount // 2)
            for _ in range(presses):
                pyautogui.press("volumeup")
            return True, f"Increased volume"
        
        return False, "pyautogui not available for volume control"
    
    def _volume_down(self, cmd: Dict) -> Tuple[bool, str]:
        """Decrease volume."""
        extra = cmd.get("extra", {})
        amount = extra.get("amount", 10) if isinstance(extra, dict) else 10
        
        if PYAUTOGUI_AVAILABLE:
            presses = max(1, amount // 2)
            for _ in range(presses):
                pyautogui.press("volumedown")
            return True, f"Decreased volume"
        
        return False, "pyautogui not available for volume control"
    
    def _mute(self, cmd: Dict) -> Tuple[bool, str]:
        """Mute/unmute audio."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.press("volumemute")
            return True, "Toggled mute"
        
        return False, "pyautogui not available for volume control"
    
    def _screenshot(self, cmd: Dict) -> Tuple[bool, str]:
        """Take a screenshot."""
        extra = cmd.get("extra", {})
        save_path = extra.get("save_path", "") if isinstance(extra, dict) else ""
        
        if not save_path:
            # Default path
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            save_path = os.path.join(
                self.user_home, "Pictures", "Screenshots", f"screenshot_{timestamp}.png"
            )
        
        # Ensure directory exists
        os.makedirs(os.path.dirname(save_path), exist_ok=True)
        
        if PYAUTOGUI_AVAILABLE:
            screenshot = pyautogui.screenshot()
            screenshot.save(save_path)
            return True, f"Screenshot saved to {save_path}"
        else:
            # Use Windows Snipping Tool as fallback
            subprocess.Popen(["snippingtool", "/clip"])
            return True, "Opened Snipping Tool"
    
    def _lock_screen(self, cmd: Dict) -> Tuple[bool, str]:
        """Lock the computer."""
        ctypes.windll.user32.LockWorkStation()
        return True, "Screen locked"
    
    def _shutdown(self, cmd: Dict) -> Tuple[bool, str]:
        """Shutdown the computer."""
        extra = cmd.get("extra", {})
        delay = extra.get("delay", 0) if isinstance(extra, dict) else 0
        
        subprocess.Popen(f"shutdown /s /t {delay}", shell=True)
        return True, f"Shutdown scheduled in {delay} seconds"
    
    def _restart(self, cmd: Dict) -> Tuple[bool, str]:
        """Restart the computer."""
        extra = cmd.get("extra", {})
        delay = extra.get("delay", 0) if isinstance(extra, dict) else 0
        
        subprocess.Popen(f"shutdown /r /t {delay}", shell=True)
        return True, f"Restart scheduled in {delay} seconds"
    
    def _sleep(self, cmd: Dict) -> Tuple[bool, str]:
        """Put computer to sleep."""
        subprocess.Popen("rundll32.exe powrprof.dll,SetSuspendState 0,1,0", shell=True)
        return True, "Computer going to sleep"
    
    def _system_info(self, cmd: Dict) -> Tuple[bool, str]:
        """Get system information like battery, time, etc."""
        extra = cmd.get("extra", {})
        info_type = extra.get("type", "general") if isinstance(extra, dict) else "general"
        
        results = []
        
        if info_type in ["battery", "general", "all"]:
            # Get battery info using PowerShell
            try:
                result = subprocess.run(
                    ["powershell", "-Command", 
                     "(Get-WmiObject Win32_Battery).EstimatedChargeRemaining"],
                    capture_output=True, text=True, timeout=5
                )
                battery_percent = result.stdout.strip()
                if battery_percent:
                    results.append(f"üîã Battery: {battery_percent}%")
                    
                    # Check if plugged in
                    result2 = subprocess.run(
                        ["powershell", "-Command",
                         "(Get-WmiObject Win32_Battery).BatteryStatus"],
                        capture_output=True, text=True, timeout=5
                    )
                    status = result2.stdout.strip()
                    if status == "2":
                        results.append("‚ö° Status: Charging")
                    elif status == "1":
                        results.append("üîå Status: On Battery")
                else:
                    results.append("üîã Battery: Unable to detect (desktop PC?)")
            except Exception as e:
                results.append(f"üîã Battery: Error getting info - {str(e)}")
        
        if info_type in ["time", "datetime", "general", "all"]:
            now = datetime.now()
            results.append(f"üïê Time: {now.strftime('%I:%M %p')}")
            results.append(f"üìÖ Date: {now.strftime('%B %d, %Y')}")
        
        if info_type in ["memory", "ram", "all"]:
            try:
                result = subprocess.run(
                    ["powershell", "-Command",
                     "Get-WmiObject Win32_OperatingSystem | Select-Object -Property FreePhysicalMemory,TotalVisibleMemorySize"],
                    capture_output=True, text=True, timeout=5
                )
                results.append(f"üíæ Memory info retrieved")
            except Exception:
                pass
        
        if info_type in ["disk", "storage", "all"]:
            try:
                result = subprocess.run(
                    ["powershell", "-Command",
                     "Get-WmiObject Win32_LogicalDisk -Filter 'DeviceID=\"C:\"' | Select-Object -Property FreeSpace,Size"],
                    capture_output=True, text=True, timeout=5
                )
                results.append(f"üíø Disk info retrieved")
            except Exception:
                pass
        
        if results:
            message = "\n".join(results)
            print(f"\n{'='*40}")
            print("üìä SYSTEM INFO")
            print('='*40)
            print(message)
            print('='*40 + "\n")
            return True, message
        else:
            return False, "Could not retrieve system information"
    
    def _web_search(self, cmd: Dict) -> Tuple[bool, str]:
        """Open browser and search the web."""
        extra = cmd.get("extra", {})
        query = extra.get("query", "") if isinstance(extra, dict) else ""
        browser = extra.get("browser", "chrome") if isinstance(extra, dict) else "chrome"
        
        if not query:
            query = cmd.get("target", "")
        
        if not query:
            return False, "No search query provided"
        
        # URL encode the query
        import urllib.parse
        encoded_query = urllib.parse.quote_plus(query)
        search_url = f"https://www.google.com/search?q={encoded_query}"
        
        # Try to find browser
        browser_paths = {
            "chrome": [
                r"C:\Program Files\Google\Chrome\Application\chrome.exe",
                r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
                os.path.join(self.user_home, r"AppData\Local\Google\Chrome\Application\chrome.exe"),
            ],
            "edge": [
                r"C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe",
                r"C:\Program Files\Microsoft\Edge\Application\msedge.exe",
            ],
            "firefox": [
                r"C:\Program Files\Mozilla Firefox\firefox.exe",
                r"C:\Program Files (x86)\Mozilla Firefox\firefox.exe",
            ],
        }
        
        browser_key = browser.lower().replace("google", "").strip()
        if "chrome" in browser_key or browser_key == "":
            browser_key = "chrome"
        elif "edge" in browser_key:
            browser_key = "edge"
        elif "firefox" in browser_key:
            browser_key = "firefox"
        
        paths = browser_paths.get(browser_key, browser_paths["chrome"])
        
        for path in paths:
            if os.path.exists(path):
                subprocess.Popen([path, search_url])
                return True, f"Searching for '{query}' in {browser_key}"
        
        # Fallback to default browser
        os.startfile(search_url)
        return True, f"Searching for '{query}' in default browser"
    
    # ============ ADVANCED FRIDAY CONTROLS ============
    
    def _brightness_up(self, cmd: Dict) -> Tuple[bool, str]:
        """Increase screen brightness."""
        extra = cmd.get("extra", {})
        amount = extra.get("amount", 10) if isinstance(extra, dict) else 10
        try:
            subprocess.run(
                ["powershell", "-Command",
                 f"(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods).WmiSetBrightness(1, "
                 f"[Math]::Min(100, (Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness).CurrentBrightness + {amount}))"],
                capture_output=True, timeout=5
            )
            return True, f"Brightness increased by {amount}%"
        except Exception as e:
            # Fallback using keyboard shortcut (Fn+brightness keys not available)
            return False, f"Could not adjust brightness: {e}"
    
    def _brightness_down(self, cmd: Dict) -> Tuple[bool, str]:
        """Decrease screen brightness."""
        extra = cmd.get("extra", {})
        amount = extra.get("amount", 10) if isinstance(extra, dict) else 10
        try:
            subprocess.run(
                ["powershell", "-Command",
                 f"(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods).WmiSetBrightness(1, "
                 f"[Math]::Max(0, (Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness).CurrentBrightness - {amount}))"],
                capture_output=True, timeout=5
            )
            return True, f"Brightness decreased by {amount}%"
        except Exception as e:
            return False, f"Could not adjust brightness: {e}"
    
    def _set_brightness(self, cmd: Dict) -> Tuple[bool, str]:
        """Set screen brightness to specific level."""
        extra = cmd.get("extra", {})
        level = extra.get("level", 50) if isinstance(extra, dict) else 50
        level = max(0, min(100, level))
        try:
            subprocess.run(
                ["powershell", "-Command",
                 f"(Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods).WmiSetBrightness(1, {level})"],
                capture_output=True, timeout=5
            )
            return True, f"Brightness set to {level}%"
        except Exception as e:
            return False, f"Could not set brightness: {e}"
    
    def _wifi_toggle(self, cmd: Dict) -> Tuple[bool, str]:
        """Toggle WiFi on/off."""
        extra = cmd.get("extra", {})
        state = extra.get("state", "toggle") if isinstance(extra, dict) else "toggle"
        
        try:
            if state == "on":
                subprocess.run(["netsh", "interface", "set", "interface", "Wi-Fi", "enabled"], 
                             capture_output=True, timeout=5)
                return True, "WiFi enabled"
            elif state == "off":
                subprocess.run(["netsh", "interface", "set", "interface", "Wi-Fi", "disabled"],
                             capture_output=True, timeout=5)
                return True, "WiFi disabled"
            else:
                # Toggle - check current state first
                result = subprocess.run(["netsh", "interface", "show", "interface", "Wi-Fi"],
                                       capture_output=True, text=True, timeout=5)
                if "Enabled" in result.stdout:
                    subprocess.run(["netsh", "interface", "set", "interface", "Wi-Fi", "disabled"],
                                 capture_output=True, timeout=5)
                    return True, "WiFi disabled"
                else:
                    subprocess.run(["netsh", "interface", "set", "interface", "Wi-Fi", "enabled"],
                                 capture_output=True, timeout=5)
                    return True, "WiFi enabled"
        except Exception as e:
            return False, f"Could not toggle WiFi: {e}"
    
    def _bluetooth_toggle(self, cmd: Dict) -> Tuple[bool, str]:
        """Toggle Bluetooth on/off."""
        extra = cmd.get("extra", {})
        state = extra.get("state", "toggle") if isinstance(extra, dict) else "toggle"
        
        try:
            # Open Bluetooth settings (direct toggle requires complex WinRT APIs)
            subprocess.Popen("start ms-settings:bluetooth", shell=True)
            return True, "Opened Bluetooth settings. Toggle Bluetooth from there."
        except Exception as e:
            return False, f"Could not open Bluetooth settings: {e}"
    
    def _kill_process(self, cmd: Dict) -> Tuple[bool, str]:
        """Kill a process by name."""
        target = cmd.get("target", "")
        if not target:
            return False, "No process name specified"
        
        # Add .exe if not present
        if not target.lower().endswith(".exe"):
            target += ".exe"
        
        try:
            result = subprocess.run(["taskkill", "/IM", target, "/F"],
                                   capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                return True, f"Process {target} terminated"
            else:
                return False, f"Could not kill {target}: {result.stderr}"
        except Exception as e:
            return False, f"Error killing process: {e}"
    
    def _list_processes(self, cmd: Dict) -> Tuple[bool, str]:
        """List running processes."""
        extra = cmd.get("extra", {})
        top_n = extra.get("count", 10) if isinstance(extra, dict) else 10
        
        try:
            result = subprocess.run(
                ["powershell", "-Command",
                 f"Get-Process | Sort-Object WorkingSet64 -Descending | "
                 f"Select-Object -First {top_n} Name,@{{Name='MemMB';Expression={{[math]::Round($_.WorkingSet64/1MB,0)}}}} | "
                 "Format-Table -AutoSize"],
                capture_output=True, text=True, timeout=10
            )
            processes = result.stdout.strip()
            print(f"\nüìä Top {top_n} Running Processes:\n{processes}")
            return True, f"Listed top {top_n} processes"
        except Exception as e:
            return False, f"Error listing processes: {e}"
    
    def _media_play_pause(self, cmd: Dict) -> Tuple[bool, str]:
        """Play/Pause media."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.press('playpause')
            return True, "Media play/pause toggled"
        else:
            # Use virtual key code
            try:
                import ctypes
                ctypes.windll.user32.keybd_event(0xB3, 0, 0, 0)  # VK_MEDIA_PLAY_PAUSE
                ctypes.windll.user32.keybd_event(0xB3, 0, 2, 0)  # Key up
                return True, "Media play/pause toggled"
            except Exception:
                return False, "Could not toggle media"
    
    def _media_next(self, cmd: Dict) -> Tuple[bool, str]:
        """Next media track."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.press('nexttrack')
            return True, "Skipped to next track"
        else:
            try:
                import ctypes
                ctypes.windll.user32.keybd_event(0xB0, 0, 0, 0)  # VK_MEDIA_NEXT_TRACK
                ctypes.windll.user32.keybd_event(0xB0, 0, 2, 0)
                return True, "Skipped to next track"
            except Exception:
                return False, "Could not skip track"
    
    def _media_previous(self, cmd: Dict) -> Tuple[bool, str]:
        """Previous media track."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.press('prevtrack')
            return True, "Skipped to previous track"
        else:
            try:
                import ctypes
                ctypes.windll.user32.keybd_event(0xB1, 0, 0, 0)  # VK_MEDIA_PREV_TRACK
                ctypes.windll.user32.keybd_event(0xB1, 0, 2, 0)
                return True, "Skipped to previous track"
            except Exception:
                return False, "Could not skip track"
    
    def _media_stop(self, cmd: Dict) -> Tuple[bool, str]:
        """Stop media playback."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.press('stop')
            return True, "Media stopped"
        else:
            try:
                import ctypes
                ctypes.windll.user32.keybd_event(0xB2, 0, 0, 0)  # VK_MEDIA_STOP
                ctypes.windll.user32.keybd_event(0xB2, 0, 2, 0)
                return True, "Media stopped"
            except Exception:
                return False, "Could not stop media"
    
    def _open_url(self, cmd: Dict) -> Tuple[bool, str]:
        """Open a specific URL in browser."""
        target = cmd.get("target", "")
        extra = cmd.get("extra", {})
        url = extra.get("url", target) if isinstance(extra, dict) else target
        
        if not url:
            return False, "No URL specified"
        
        # Add https:// if no protocol specified
        if not url.startswith(("http://", "https://")):
            url = "https://" + url
        
        try:
            os.startfile(url)
            return True, f"Opened {url}"
        except Exception as e:
            return False, f"Could not open URL: {e}"
    
    def _new_tab(self, cmd: Dict) -> Tuple[bool, str]:
        """Open new browser tab."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey('ctrl', 't')
            return True, "Opened new tab"
        return False, "PyAutoGUI not available"
    
    def _close_tab(self, cmd: Dict) -> Tuple[bool, str]:
        """Close current browser tab."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey('ctrl', 'w')
            return True, "Closed current tab"
        return False, "PyAutoGUI not available"
    
    def _refresh_page(self, cmd: Dict) -> Tuple[bool, str]:
        """Refresh current page."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.press('f5')
            return True, "Page refreshed"
        return False, "PyAutoGUI not available"
    
    def _empty_recycle_bin(self, cmd: Dict) -> Tuple[bool, str]:
        """Empty the recycle bin."""
        try:
            import ctypes
            # SHEmptyRecycleBin with no confirmation dialog
            ctypes.windll.shell32.SHEmptyRecycleBinW(None, None, 0x07)
            return True, "Recycle bin emptied"
        except Exception as e:
            return False, f"Could not empty recycle bin: {e}"
    
    def _show_desktop(self, cmd: Dict) -> Tuple[bool, str]:
        """Show desktop (minimize all windows)."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey('win', 'd')
            return True, "Showing desktop"
        else:
            try:
                import ctypes
                ctypes.windll.user32.keybd_event(0x5B, 0, 0, 0)  # Win key down
                ctypes.windll.user32.keybd_event(0x44, 0, 0, 0)  # D key down
                ctypes.windll.user32.keybd_event(0x44, 0, 2, 0)  # D key up
                ctypes.windll.user32.keybd_event(0x5B, 0, 2, 0)  # Win key up
                return True, "Showing desktop"
            except Exception:
                return False, "Could not show desktop"
    
    def _open_emoji_picker(self, cmd: Dict) -> Tuple[bool, str]:
        """Open Windows emoji picker."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey('win', '.')
            return True, "Opened emoji picker"
        return False, "PyAutoGUI not available"
    
    def _open_clipboard_history(self, cmd: Dict) -> Tuple[bool, str]:
        """Open clipboard history."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey('win', 'v')
            return True, "Opened clipboard history"
        return False, "PyAutoGUI not available"
    
    def _night_light_toggle(self, cmd: Dict) -> Tuple[bool, str]:
        """Toggle night light / blue light filter."""
        try:
            subprocess.Popen("start ms-settings:nightlight", shell=True)
            return True, "Opened Night Light settings"
        except Exception as e:
            return False, f"Could not open Night Light settings: {e}"
    
    def _airplane_mode_toggle(self, cmd: Dict) -> Tuple[bool, str]:
        """Toggle airplane mode."""
        try:
            subprocess.Popen("start ms-settings:network-airplanemode", shell=True)
            return True, "Opened Airplane Mode settings"
        except Exception as e:
            return False, f"Could not open Airplane Mode settings: {e}"
    
    def _type_text(self, cmd: Dict) -> Tuple[bool, str]:
        """Type text using keyboard."""
        extra = cmd.get("extra", {})
        text = extra.get("text", "") if isinstance(extra, dict) else ""
        
        if not text:
            text = cmd.get("target", "")
        
        if not text:
            return False, "No text to type"
        
        if PYAUTOGUI_AVAILABLE:
            pyautogui.write(text, interval=0.02)
            return True, f"Typed: {text[:50]}..."
        return False, "PyAutoGUI not available"
    
    def _scroll(self, cmd: Dict) -> Tuple[bool, str]:
        """Scroll the page."""
        extra = cmd.get("extra", {})
        direction = extra.get("direction", "down") if isinstance(extra, dict) else "down"
        amount = extra.get("amount", 3) if isinstance(extra, dict) else 3
        
        if PYAUTOGUI_AVAILABLE:
            if direction == "up":
                pyautogui.scroll(amount)
            else:
                pyautogui.scroll(-amount)
            return True, f"Scrolled {direction}"
        return False, "PyAutoGUI not available"
    
    def _click(self, cmd: Dict) -> Tuple[bool, str]:
        """Perform mouse click."""
        extra = cmd.get("extra", {})
        button = extra.get("button", "left") if isinstance(extra, dict) else "left"
        clicks = extra.get("clicks", 1) if isinstance(extra, dict) else 1
        x = extra.get("x") if isinstance(extra, dict) else None
        y = extra.get("y") if isinstance(extra, dict) else None
        
        if PYAUTOGUI_AVAILABLE:
            if x is not None and y is not None:
                pyautogui.click(x=x, y=y, button=button, clicks=clicks)
            else:
                pyautogui.click(button=button, clicks=clicks)
            return True, f"{button.capitalize()} click performed"
        return False, "PyAutoGUI not available"
    
    def _voice_typing(self, cmd: Dict) -> Tuple[bool, str]:
        """Activate Windows Voice Typing (Win+H)."""
        if PYAUTOGUI_AVAILABLE:
            pyautogui.hotkey('win', 'h')
            return True, "Voice typing activated. Speak now!"
        return False, "PyAutoGUI not available"


# Convenience function
def execute_command(command: Dict[str, Any]) -> Tuple[bool, str]:
    """Execute a Windows command."""
    executor = CommandExecutor()
    return executor.execute(command)


if __name__ == "__main__":
    # Test the executor
    executor = CommandExecutor()
    
    test_commands = [
        {"action": "open_app", "target": "notepad.exe"},
        {"action": "open_folder", "path": "C:/Users"},
        {"action": "screenshot"},
    ]
    
    print("Testing Command Executor")
    print("=" * 40)
    
    for cmd in test_commands:
        print(f"\nCommand: {json.dumps(cmd)}")
        success, message = executor.execute(cmd)
        status = "‚úÖ" if success else "‚ùå"
        print(f"{status} {message}")
